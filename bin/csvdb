#!perl

use strict;
use warnings;

#  2021-1010: Command line interface to the CSVDB module.

use Term::ReadLine;

use CSVDB;

my $base_prompt = 'csvdb > ';
my $prompt = $base_prompt;      #  Might show currently loaded file?

my $done = 0;
my $table;

my %cmds = (
    'q' => { exec => sub { $done = 1; }, short => 'Quit csvdb command line' },
    'h' => { exec => sub { help(); },    short => 'Show help' },
    'o' => {
        exec  => sub { my ($param) = @_; open_file( $param->[0], 1 ); },
        short => 'Open CSV file with header'
    },
    'op' => {
        exec  => sub { my ($param) = @_; open_file( $param->[0], 0 ); },
        short => 'Open CSV file without header (plain)'
    },
);

my %sql = (
    'select' => { exec => sub { &select; }, short => 'Select records' },
);

{
    my $term = Term::ReadLine->new('csvdb');

    print $prompt;
    my $input;

    while ( defined( $input = $term->readline($prompt) ) ) {

        # $input =~ s/\s+$//;

        print "DEBUG: input: $input\n";

        my @words = split( / /, $input );
        my $cmd = shift @words;

        #  We're dealing with two things here .. single letter commands (listed
        #  above in the cmds hash) and actual SQL operations (list in the sql
        #  hash). If they're not in either of the hashes, it's a bad command.

        if ( exists $cmds{ $cmd } ) {

            &{ $cmds{ $cmd }->{ exec } }( [ @words ] );
        }

        elsif ( exists $sql{ $cmd } ) {

            &{ $sql{ $cmd }->{ exec } }( [ @words ] );

        } else {

            print "ERROR: Didn't recognize the $cmd command.\n";
        }

        last if ($done);
    }
}

sub help
{
    print join( "\n", map { "$_ : $cmds{$_}->{short}"; } sort keys %cmds )
      . "\n";
}

sub open_file
{
    my ( $filename, $header_present ) = @_;
    
    if ( !defined ( $filename ) ) {

        print "ERROR: Must specify a CSV filename\n";
        return;
    }

    if ( -e $filename ) {

        print "INFO: Hey, $filename exists! Cool.\n";

        $table = CSVDB->new($filename, $header_present);

        if ( defined $table ) {

            print "INFO: Cool, object successfully created.\n";

        } else {

            print "ERROR: Ugh, problems: " . join ( "\n", @CSVDB::errors ) . "\n";
        }
    }
}

sub open_file_without_header
{
    my ( $array_ref ) = @_;
    my $filename = $array_ref->[0];
    
    if ( !defined ( $filename ) ) {

        print "ERROR: Must specify a CSV filename\n";
        return;
    }

    if ( -e $filename ) {

        print "INFO: Hey, $filename exists! Cool.\n";
        $table = CSVDB->new_no_header ( $filename );

        if ( defined $table ) {

            print "INFO: Cool, object successfully created.\n";

        } else {

            print "ERROR: Ugh, problems: " . join ( "\n", @CSVDB::errors ) . "\n";
        }
    }
}

sub select
{
    my ( @params ) = @_;

    if ( !defined $table ) {

        print "ERROR: Oops, you need to open a CSV file first.\n";
        return;
    }

    #  The params can have a field list, separated by commas, and optinally a
    #  where clause and a limit clause (for now). Let's see if we can catch all
    #  of those eventualities.

    print "DEBUG: params are " . join ( ' / ', @{$params[0]} ) . "\n";

    #  Field list ..

    my @fields;
    while ( my $p  = shift @{ $params[0] } ) {

        print "DEBUG: Look at '$p'\n";

        if ( $p =~ /,/ ) {

            push( @fields, split( /,\s*/, $p ) );

        } else {

            if ( $p =~ /\w/ ) { push( @fields, $p ); last; }
        }
    }

    print "DEBUG: Fields are " . join ( ' / ', @fields ) . "\n";

    my %args = ( fields => \@fields );

    print "DEBUG: remaining params are " . join ( ' / ', @{$params[0]} ) . "\n";

    #  Where clause (to come) ..

    #  Limit clause ..

    if ( $params[0]->[0] eq 'limit' ) {

        print "DEBUG: Limit is $params[0]->[1]\n";
        $args{ limit } = $params[0]->[1];

        my $used = shift @{ $params[0] };
    }

    print "DEBUG: remaining params are " . join ( ' / ', @{$params[0]} ) . "\n";

    my $result = $table->select ( %args );

    foreach my $row ( @$result ) {

        print join ( "\t", @{ $row } ) . "\n";
    }
}
